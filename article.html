<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <p>People always want more. More of everything. And there is nothing better in the world to fulfil that need than particle systems. Because you can have thousands of particles easily. And thats what i did.</p>
    <video src="final.mp4" autoplay muted width="600"></video>
    <h2>How to create particle syste?</h2>
    <p>You start with just one particle, i like to use classes for that, because that perfetly describes behaviour of particles. usually it looks like this:</p>
    <pre>
        class Particle{
            // just setting initial position and speed
            constructor(){}
            // updating velocity according to position and physics
            updateVelocity(){}
            // finally update particle position, 
            // sometimes these last two could be merged
            updatePosition(){}
        }
    </pre>

    <p>And after all of that, you could render them. Sounds easy, right? It is!</p>

    <h2>Physics</h2>
    <p>So the particles need to move, for that we need to establish some rules for their movement. The easiest one is: gravity. Implemented in particle it would look like this:</p>
    <pre>
        updateVelocity(){
            this.speed.y = gravity; // some constant
        }
        updatePosition{
            // this could have been just one line, but imagine there are some other factors for speed, not just gravity.
            this.position.y += this.speed.y;

            // also some code to bring particle back to screen, once it is outside
        }
    </pre>
    <p>With that you will get this simple rain. I also randomized gravity for each particle. Because i can!</p>

    <video src="notrails.mp4" autoplay muted width="600"></video>

    <p>But just rain didnt seem enough, and i decided to add a little bit of physics to change speed of particles. To slow them down or speed them up, depending on the... image. Yup, i took physics for particles from image. My friend @EncharmDre proposed to use some oscillations for particles, and i also added some colors palletes here. It looked amazing! Like a real tropical rain.</p>
    <video src="final.mp4" autoplay muted width="600"></video>

    <p>Still, this physics part is the computational bottleneck for this animation. It is possible to animate millions of particles by using GPGPU techniques, and by using GPU to calculate positions. But 10000 particles seemed enough for my demo, and i got away with CPU calculations this time. 10 thousands also were possible because i saved some performance on rendering.</p>


    <h2>Rendering</h2>
    <p>There are a lot of ways to render particles: HTML, Canvas2D, WebGL, SVG, you name it. But so far the fastest one is of course WebGL. It is even faster than Canvas2D rendering. I mean, of course Canvas2D works perfectly fine for particles. But with WebGL you could have MORE OF THEM! Which is the point of this whole adventure =). </p>
    <p>So, WebGL narrowed down search for rendering to a couple of frameworks. PIXI.js is actually very nice for rendering 2D particle systems, but because i love three.js, and because its always nice to have another dimension as a backup(the more dimensions the better, remember?), i chose THREE.js for this job.</p>
    <p>There is already an object specifically for this job: <code>THREE.Points</code>. I also decided to use shaders (because its cool) but you could actually easily avoid that for this demo.</p>
    <p>The simplified code looks somewhat like this:</p>

    <pre>
        // initialization
        for (let i = 0; i < numberOfParticles; i++) {
          // because we are animating them in 2D, z=0
          positions.set([x, y, 0], i * 3);
          this.particles.push(
            new Particle({
              x,
              y
            })
          );
        }
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );

        // animation loop
        particles.forEach(particle => {
          particle.updateSpeedAndPosition();
        });
    </pre>

    <p>To make it even cooler, i decided to create trails for particles, for that i just used previous rendering frame, and faded it a little bit. And here is what i got:</p>

    <video src="rain.mp4" autoplay muted width="600"></video>
    <p>Now combining everything, we could acheive this final look:</p>
    <video src="final.mp4" autoplay muted width="600"></video>

    <h2>In the end</h2>
    <p>I beg you to try this yourself, and experiment with different parameters for particles, or write your own logic for their behavior. It is a lot of fun. And you could be the ruler of thousands or even millions of... particles!</p>
    
</body>
</html>